#ifndef FASTRS_H
#define FASTRS_H

#define FASTRS_INT_ID_OFFSET		4
#define FASTRS_INT_ID				XPAR_FABRIC_XLCONCAT_0_DOUT_INTR + FASTRS_INT_ID_OFFSET

#ifndef PILOT_TARGET
    #error "Define PILOT_TARGET in pilot_cfg.h"
#endif

#if PILOT_TARGET == PT_HARDWARE

/** \file
* \brief Declaration of a class supporting port of a fast serial transmission up to 460800bps
*/

/** Class supports port of a fast serial transmission up to 460800 bits per second.
* Send lines are stored in a cyclic buffer from where a dedicated task of an uC/OS-II operating system
* gets them and sends on a serial port. Received lines are collecting and completing in a working buffer.
* When an end of line character is reached, the working buffer is switched to a result buffer and the notification
* is send.
*/
/// Implementation of a class supporting port of a fast serial transmission up to 460800bps
class FastRS: public ODTObserver, public SerialDeviceBase
{
public:
    FastRS(CPU_INT32U portID, int baudRate = 0, int outBufLines = 10);
    bool getLastLine(char* lineReceived);
    bool sendLine (const char* lineToSend, bool suppressErrMsg = false, bool withWaiting = false,
        bool withCrc = false);
    bool sendBinary (const unsigned char* buf, int size);        
    void taskIn(void* pdata);
    void taskOut(void* pdata);
    void linkObserver();		///< Method links observed objects

private:
    // Destructor is disabled - object should never be destroyed
    ~FastRS(void){};

    static const int ERRWAIT = 10;			///< Waiting time in seconds after the occurrence of an error (protection against clogging the log) 
    static const int MAX_WAIT_QUEUE = 115;	///< Value of a queue lenght above which waiting for a send is activated (when wait==true)
    static const int MAX_SEND_TRIALS = 8;	///< Number of tries to send a line (when wait==true)
    static const int SEND_WAIT_TICKS = 5;	///< Waiting time between the tries to send a line (ticks)
    static const int FAST_RS_BUFFER_SIZE = 1024;	///< Length of an output buffer

    //
    static const int  FAST_RS_DIVISOR_OFFSET 		= 0*4;
    static const int  FAST_RS_WR_FIFO_OFFSET 		= 1*4;
    static const int  FAST_RS_RESET_IRQ_OFFSET 		= 2*4;
    static const int  FAST_RS_RD_CONTROL_OFFSET 	= 0*4;
    static const int  FAST_RS_RD_FIFO_OFFSET 		= 1*4;

	/** \name Structure of an FastRS control register (0x00)
	* \{
	*/
    typedef union fastRSControl_t{
        struct bits {
            u32 baud_div     :  7; ///< Baudrate divisor (0=460800, 1=230400, 3=115200, 7=57600, 11=38400, 23=19200, 47=9600)
            u32 tx_level     : 10; ///< Number of bytes in TX FIFO (max. 1023)
            u32 rx_level     : 10; ///< Number of bytes in RX FIFO (max. 1023)
            u32 dummy        :  3; ///< dummy
            u32 rxe          :  1; ///< RX empty flag
            u32 txe          :  1; ///< TX empty flag
        } bits;
        u32 word;
    }fastRSControl_t;
	///\}

    typedef char TLine[LINESIZE];
    void open(const char* portName, int baudRate, int outBufLines);

    TLine buf1;             ///< Place holder for a working buffer or an output buffer (switchable)
    TLine buf2;             ///< Place holder for a working buffer or an output buffer (switchable)
    char* work;             ///< Pointer to the working buffer which receive the characters
    char* lastLine;         ///< Pointer to the output buffer with received line
    OS_EVENT* mboxSig;      ///< Mailbox to synchronize the sending task
    Semaphore _outBufSem;   ///< Semaphore controlling access to the cyclic buffer (at transmitting)
    Semaphore _inBufSem;    ///< Semaphore controlling access to the output buffer (at receiving)
    bool _clearInputFlag;   ///< Flag of an request to clear an output buffer
    int nLines;             /// Number of lines in a cyclic buffer
    TLine* outLinesBuffer;  ///< Cyclic buffer with lines to be send
    int lUser, lSystem;     ///< Positions in a cyclic buffer
    int _maxWaitQueue;      ///< Value of a queue lenght above which waiting for a send is activated (when wait==true)
    int _irqFastRSTag;      ///< Tag generated by a FastRS
};

#endif // PILOT_TARGET
#endif // FASTRS_H
