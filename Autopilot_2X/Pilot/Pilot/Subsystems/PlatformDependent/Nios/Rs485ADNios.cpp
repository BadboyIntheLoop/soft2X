#include <PilotIncludes.h>

#ifndef PILOT_TARGET
    #error "Define PILOT_TARGET in pilot_cfg.h"
#endif

// Compilation on Windows only for static analysis purpose
#if (PILOT_TARGET == PT_HARDWARE) || (PILOT_TARGET == PT_WIN32)

// Initialization of a class static members (initiliazation with 0)
unsigned int Rs485ADNios::nInstances = 0u;
OS_FLAG_GRP* Rs485ADNios::evtFlagGrp = NULL;

/** \name Class constructor
* Object should be created at the start of an application (after execution of an 'OSInit()').
* In case of failure the initial state is not restored - ignore the device or run the program again. Object shouldn't be destroyed (destructor is disabled).
* \param 'baseAddr' - base address of a device in process address space
* \param 'irqNo' - identifier of an interruption generated by a device
* \param 'bdRate' - transmission speed (115200, 230400, 460800)
*/
Rs485ADNios::Rs485ADNios(u32 baseAddr, u32 irqNo, u32 bdRate):
    IAsyncDevice(), m_baseAddr(baseAddr), m_irqNo(irqNo), m_bdRate(bdRate), m_instanceNo(0u), m_usable(false)
{
    if (nInstances >= MAX_INSTANCES)
        return;

    // Setting a value of a field corresponding to the baud rate
    if (460800u == bdRate)
        bdRateDivisor = 0u;
    else if (230400u == bdRate)
        bdRateDivisor = 1u;
    else if (115200u == bdRate)
        bdRateDivisor = 2u;
    else
        return;

	// Counting of an class instances
    m_instanceNo = nInstances++;

	// Setting the device control register
    RS485Control_t ctrl;
    ctrl.word = 0;
    ctrl.bits.baud_div = bdRateDivisor & 0x1Fu;    // Transmission speed
    ctrl.bits.module_enable = 1u;                   // Activating the RS485 module
    ctrl.bits.echo_disable = 1u;                    // Disabling 'echo'
	// Storing flags to the control register

	// Creation of a group of event flags supporting communication between user handler and an object of this class (only for first object creation)
    if (m_instanceNo == 0)
    {
        INT8U perr = 0u;
        evtFlagGrp = OSFlagCreate (0u, &perr);
        if (perr != OS_ERR_NONE)
            return;
    }

    // The object is created correctly
    m_usable = true;
}

/** \name Method sends data through device with waiting on accessibility of that device and termination of transmission.
* For detailed description refer to IAsyncDevice.
* \param 'buf' - data to send
* \param 'nbytes' - number of bytes to send
* \return 'true' on success, 'false' otherwise
*/
bool Rs485ADNios::sendBufferWait (const unsigned char* buf, int nBytes)
{
	// Checking whether the object was created correctly
    if (!m_usable)
        return false;

	// Waiting for a free space in a transmitter's FIFO queue
	// Device doesn't notify any interruption requests for sending data so if queue is full loop must by delayed for a 1 tick (0-10ms)
	// For a 10ms a number of 460 bytes are transmitted with transmission speed set to 460800
    RS485Control_t ctrl;
    while (true)
    {
        ctrl.word = 0;
        if ((ctrl.bits.tx_level + static_cast<u32>(nBytes)) >= SEND_FIFO_SIZE)
            OSTimeDly (1u);
        else
            break;
    }

	// Sending of a data
    for (int i=0; i<nBytes; i++)
    {
    }

    return true;
}

/** \name Method reads a data through a device. Waits without timeout for the beginning of a transmission. Method returns after
* reading specified number of bytes or reading an LF(CR) character. For a detail description refer to IAsyncDevice.
* \param 'buf' - buffer for a read data
* \param 'bufSize' - buffer size
* \param 'nBytes' - number of read bytes (important if there was an LF character)
* \return 'true' on success, 'false' otherwise
*/
bool Rs485ADNios::recvBufferWait (unsigned char* buf, int bufSize, int& nBytes)
{
 	// Check if object was created correctly
    if (!m_usable)
        return false;

	// An EV_INT_RCV event bit is set when interruption handler have received an LF(0x0A) character
	// Bits of a particular devices are shifted left by a value (multiple of 4)
    const OS_FLAGS f = (EV_INT_RCV) << (FL_BITS_INST * m_instanceNo);

    // Reading of a control word
	RS485Control_t ctrl;

    ctrl.word = 0;

	// If the device buffer is not empty then event flag is going to be set (the same flag which
	//  is set by an interruption handler when it recognizes the end of line character)
    INT8U perr = 0u;
    if (ctrl.bits.rx_level > 0)
        OSFlagPost(evtFlagGrp, f, OS_FLAG_SET, &perr);  

 	// Waiting for an event (no timeout)
    OSFlagPend(evtFlagGrp, f, OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME, 0u, &perr);

    for (nBytes=0; nBytes<(bufSize-1); nBytes++)
    {

        ctrl.word = 0;
        if (0u == ctrl.bits.rx_level)
            // All characters has been read
            break;
        int t = 0;
        buf[nBytes] = static_cast<unsigned char>(t);
    }
    buf[nBytes] = 0;
    
    return true;
}

/** \name Method returns an object creation status
* \return 'true' if object was created correctly, 'false' otherwise
*/
inline bool Rs485ADNios::isUsable (void) const
{
    return m_usable;
}

/** \name Method handles interruptions for all RS485 devices (new type). Method is static. Interruption is generated when
* there is an LF(0x0A) character in a receiving buffer.
* \param 'context' - pointer to the object of this class which handles specified instance of a device
* \param 'id' - interruption identifier
*/
void Rs485ADNios::intHandler (void* context, u32 id)
{
    if (NULL == context)
        return;

    // Pointer to the object handling this instance of a device
    Rs485ADNios* instancePtr = reinterpret_cast<Rs485ADNios*>(context);



	// Four first bits of a mask are mapped to the EventFlags bits of a uC/OS-II system
	// Variable EventFlags  has 32 bits of length and it's common for all devices of this class
	// Bits of a particular devices are shifted left by a value (multiple of 4)
    OS_FLAGS f = (EV_INT_RCV) << (FL_BITS_INST * instancePtr->m_instanceNo);
 
    // Sending notification of an event to the users thread
	INT8U perr = 0u;
    if (f > 0)
        OSFlagPost(evtFlagGrp, f, OS_FLAG_SET, &perr);
    // Possible errors are ignored
}

#endif  // PILOT_TARGET
